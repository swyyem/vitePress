# vue中的跨域问题

## 核心

- 跨域问题本质上是浏览器为了安全而实施的‘同源策略’导致的，它阻止了前端JavaScript向不同源（协议、域名、端口任一不同）的后端服务器发起请求。Vue项目本身运行在浏览器中，所以会遇到这个问题。我们通常在前端开发阶段通过配置vue.config.js中的devServer.proxy来设置代理，从而绕过浏览器的同源限制

## 1. 什么是跨域？为什么会有跨域？

- 同源策略：这是浏览器的核心安全机制。它要求网页的**协议（http/https）、域名（IP/地址）、端口**必须完全相同，才被认为是“同源”的。只要有一个不同，就是“跨域”了。

- 举个例子：

1. 你的Vue项目运行在：`http://localhost:8080`
2. 你想请求的接口是：`http://api.myapp.com:3000`
3. 这里**域名**和**端口**都不同，浏览器就会阻止你从`localhost:8080`发起的请求。

- **为什么要有这个限制？** 为了防止恶意网站通过脚本窃取另一个网站的数据（比如你的银行Cookie）。这是一个非常重要的安全屏障。

## 2. Vue项目中如何解决跨域？（开发阶段）

在开发阶段，我们最常用、最推荐的方式是使用 **Webpack DevServer 的代理**。

- **原理（通俗解释）：**、

1. 我们可以把代理想象成一个“中间人”或者“翻译官”。我们的Vue项目（浏览器）和这个“中间人”是同源的（因为它们都在localhost上，只是端口可能不同）。然后，由这个“中间人”帮我们去请求真正的后端服务器。因为服务器之间通信没有同源策略的限制，所以请求可以成功

- **流程：**

1. 浏览器（`localhost:8080`） -> 请求 -> 代理服务器（`localhost:8080`）【同源，成功】
2. 代理服务器（`localhost:8080`） -> 请求 -> 后端API（`api.myapp.com:3000`）【服务器间无限制，成功】
3. 代理服务器拿到数据后，再返回给浏览器

- 具体配置（在`vue.config.js`文件中）：

```javascript
module.exports = {
  devServer: {
    proxy: {
      // 当你请求的路径以 '/api' 开头时，就会触发代理
      '/api': {
        target: 'http://api.myapp.com:3000', // 你要代理到的后端地址
        changeOrigin: true, // 非常重要！改变请求头中的Origin为目标地址
        pathRewrite: {
          '^/api': '', // 重写路径，将请求路径中的 '/api' 替换为空字符串
        },
      },
    },
  },
};
```

- **配置解释：**

1. `‘/api’`：一个标识符。当你前端请求`/api/users`时，代理就会生效。

2. `target`：代理的目标服务器，即你的后端API地址。

3. `changeOrigin`: true：关键配置。它会将你请求头中的`Origin`字段改为`target`的值，这对于一些校验`Origin`头的服务器是必须的。

4. `pathRewrite`：可选但常用。它会把请求路径中的`/api`去掉。所以前端请求的是`/api/users`，代理实际请求的是`http://api.myapp.com:3000/users`。

## 3. 生产环境的跨域解决方案

**面试官很可能会接着问：“那上线以后怎么办？”**

开发阶段的代理只在`npm run serve`时生效。项目打包上线（`npm run build`）后，静态文件被扔到Nginx或Apache等服务器上，`vue.config.js`的代理配置就失效了。

## 生产环境的解决方案是：##

1. **配置生产环境的后端服务（CORS）：**

- 这是最主流、最正确的解决方案。由后端在响应头中设置`Access-Control-Allow-Origin`等字段，明确告诉浏览器允许哪些源的请求。

- 例如，后端可以设置 `Access-Control-Allow-Origin: https://www.myapp.com` 或者 `Access-Control-Allow-Origin: *`（不推荐，不安全）

2. **配置生产环境的Web服务器（如Nginx）反向代理:**

- 原理和开发时的Webpack代理一模一样，只是换成了在Nginx服务器上配置。
- 在Nginx的配置文件中，设置一个`location`规则，将到达Nginx的特定请求（比如`/api/`）转发到真正的后端服务器。

```nginx
location /api/ {
    proxy_pass http://backend-server.com:3000/;
    # 其他代理配置...
}
```

3. **JSONP（过时方案）：**

- 只适用于GET请求，利用`<script>`标签没有跨域限制的特性。现在基本已被CORS取代，了解即可。

## 面试回答技巧与要点总结

1. **先讲本质：** 不要一上来就说怎么配置，先说“这是浏览器的同源策略导致的”。
2. **区分环境：** 一定要清晰地分开开发环境和生产环境的解决方案。

- **开发：** Vue CLI的 devServer.proxy。
- **生产：** 后端配置CORS 或 Nginx反向代理。

3. **强调代理原理：** 能说出“代理利用服务器间通信无跨域限制”这个原理，会很加分。
4. **关键配置项：** 提到changeOrigin: true的作用。
5. **自信表达：** 这是一个非常常见的问题，回答时保持流畅和自信。

## 最终话术模板

```text
“Vue中的跨域问题，其实是所有前端框架在开发时都会遇到的经典问题。它的根源是浏览器的同源策略。

在开发阶段，我们通过在vue.config.js里配置devServer.proxy，利用Webpack-dev-server做一个代理服务器。这样，前端请求同源的代理，代理再去请求不同源的后端，就绕开了浏览器的限制。

等项目上线后，这个代理配置就不管用了。生产环境主要有两种主流方案：一是最推荐的后端配置CORS，在响应头里设置Access-Control-Allow-Origin；二是在Nginx这类Web服务器上配置反向代理，原理和开发时的代理类似。

所以，我们通常是在开发环境用Vue CLI的代理解决，上线时让后端开CORS或者运维配Nginx代理。”
```
