import{_ as i,c as a,o as n,aT as e}from"./chunks/framework.KoO-uqrk.js";const k=JSON.parse('{"title":"vue中的跨域问题","description":"","frontmatter":{},"headers":[],"relativePath":"front/interview/cross-domain.md","filePath":"front/interview/cross-domain.md"}'),l={name:"front/interview/cross-domain.md"};function p(t,s,r,o,h,c){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="vue中的跨域问题" tabindex="-1">vue中的跨域问题 <a class="header-anchor" href="#vue中的跨域问题" aria-label="Permalink to &quot;vue中的跨域问题&quot;">​</a></h1><h2 id="核心" tabindex="-1">核心 <a class="header-anchor" href="#核心" aria-label="Permalink to &quot;核心&quot;">​</a></h2><ul><li>跨域问题本质上是浏览器为了安全而实施的‘同源策略’导致的，它阻止了前端JavaScript向不同源（协议、域名、端口任一不同）的后端服务器发起请求。Vue项目本身运行在浏览器中，所以会遇到这个问题。我们通常在前端开发阶段通过配置vue.config.js中的devServer.proxy来设置代理，从而绕过浏览器的同源限制</li></ul><h2 id="_1-什么是跨域-为什么会有跨域" tabindex="-1">1. 什么是跨域？为什么会有跨域？ <a class="header-anchor" href="#_1-什么是跨域-为什么会有跨域" aria-label="Permalink to &quot;1. 什么是跨域？为什么会有跨域？&quot;">​</a></h2><ul><li><p>同源策略：这是浏览器的核心安全机制。它要求网页的<strong>协议（http/https）、域名（IP/地址）、端口</strong>必须完全相同，才被认为是“同源”的。只要有一个不同，就是“跨域”了。</p></li><li><p>举个例子：</p></li></ul><ol><li>你的Vue项目运行在：<code>http://localhost:8080</code></li><li>你想请求的接口是：<code>http://api.myapp.com:3000</code></li><li>这里<strong>域名</strong>和<strong>端口</strong>都不同，浏览器就会阻止你从<code>localhost:8080</code>发起的请求。</li></ol><ul><li><strong>为什么要有这个限制？</strong> 为了防止恶意网站通过脚本窃取另一个网站的数据（比如你的银行Cookie）。这是一个非常重要的安全屏障。</li></ul><h2 id="_2-vue项目中如何解决跨域-开发阶段" tabindex="-1">2. Vue项目中如何解决跨域？（开发阶段） <a class="header-anchor" href="#_2-vue项目中如何解决跨域-开发阶段" aria-label="Permalink to &quot;2. Vue项目中如何解决跨域？（开发阶段）&quot;">​</a></h2><p>在开发阶段，我们最常用、最推荐的方式是使用 <strong>Webpack DevServer 的代理</strong>。</p><ul><li><strong>原理（通俗解释）：</strong>、</li></ul><ol><li>我们可以把代理想象成一个“中间人”或者“翻译官”。我们的Vue项目（浏览器）和这个“中间人”是同源的（因为它们都在localhost上，只是端口可能不同）。然后，由这个“中间人”帮我们去请求真正的后端服务器。因为服务器之间通信没有同源策略的限制，所以请求可以成功</li></ol><ul><li><strong>流程：</strong></li></ul><ol><li>浏览器（<code>localhost:8080</code>） -&gt; 请求 -&gt; 代理服务器（<code>localhost:8080</code>）【同源，成功】</li><li>代理服务器（<code>localhost:8080</code>） -&gt; 请求 -&gt; 后端API（<code>api.myapp.com:3000</code>）【服务器间无限制，成功】</li><li>代理服务器拿到数据后，再返回给浏览器</li></ol><ul><li>具体配置（在<code>vue.config.js</code>文件中）：</li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">module</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">exports</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">  devServer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">    proxy</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">      // 当你请求的路径以 &#39;/api&#39; 开头时，就会触发代理</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">      &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/api</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">        target</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">http://api.myapp.com:3000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 你要代理到的后端地址</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">        changeOrigin</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 非常重要！改变请求头中的Origin为目标地址</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">        pathRewrite</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">          &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">^/api</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 重写路径，将请求路径中的 &#39;/api&#39; 替换为空字符串</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        },</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">      },</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    },</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  },</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li><strong>配置解释：</strong></li></ul><ol><li><p><code>‘/api’</code>：一个标识符。当你前端请求<code>/api/users</code>时，代理就会生效。</p></li><li><p><code>target</code>：代理的目标服务器，即你的后端API地址。</p></li><li><p><code>changeOrigin</code>: true：关键配置。它会将你请求头中的<code>Origin</code>字段改为<code>target</code>的值，这对于一些校验<code>Origin</code>头的服务器是必须的。</p></li><li><p><code>pathRewrite</code>：可选但常用。它会把请求路径中的<code>/api</code>去掉。所以前端请求的是<code>/api/users</code>，代理实际请求的是<code>http://api.myapp.com:3000/users</code>。</p></li></ol><h2 id="_3-生产环境的跨域解决方案" tabindex="-1">3. 生产环境的跨域解决方案 <a class="header-anchor" href="#_3-生产环境的跨域解决方案" aria-label="Permalink to &quot;3. 生产环境的跨域解决方案&quot;">​</a></h2><p><strong>面试官很可能会接着问：“那上线以后怎么办？”</strong></p><p>开发阶段的代理只在<code>npm run serve</code>时生效。项目打包上线（<code>npm run build</code>）后，静态文件被扔到Nginx或Apache等服务器上，<code>vue.config.js</code>的代理配置就失效了。</p><h2 id="生产环境的解决方案是" tabindex="-1">生产环境的解决方案是：## <a class="header-anchor" href="#生产环境的解决方案是" aria-label="Permalink to &quot;生产环境的解决方案是：#\\#&quot;">​</a></h2><ol><li><strong>配置生产环境的后端服务（CORS）：</strong></li></ol><ul><li><p>这是最主流、最正确的解决方案。由后端在响应头中设置<code>Access-Control-Allow-Origin</code>等字段，明确告诉浏览器允许哪些源的请求。</p></li><li><p>例如，后端可以设置 <code>Access-Control-Allow-Origin: https://www.myapp.com</code> 或者 <code>Access-Control-Allow-Origin: *</code>（不推荐，不安全）</p></li></ul><ol start="2"><li><strong>配置生产环境的Web服务器（如Nginx）反向代理:</strong></li></ol><ul><li>原理和开发时的Webpack代理一模一样，只是换成了在Nginx服务器上配置。</li><li>在Nginx的配置文件中，设置一个<code>location</code>规则，将到达Nginx的特定请求（比如<code>/api/</code>）转发到真正的后端服务器。</li></ul><div class="language-nginx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">location</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> /api/ </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">{</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    proxy_pass </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">http://backend-server.com:3000/</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    # 其他代理配置...</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="3"><li><strong>JSONP（过时方案）：</strong></li></ol><ul><li>只适用于GET请求，利用<code>&lt;script&gt;</code>标签没有跨域限制的特性。现在基本已被CORS取代，了解即可。</li></ul><h2 id="面试回答技巧与要点总结" tabindex="-1">面试回答技巧与要点总结 <a class="header-anchor" href="#面试回答技巧与要点总结" aria-label="Permalink to &quot;面试回答技巧与要点总结&quot;">​</a></h2><ol><li><strong>先讲本质：</strong> 不要一上来就说怎么配置，先说“这是浏览器的同源策略导致的”。</li><li><strong>区分环境：</strong> 一定要清晰地分开开发环境和生产环境的解决方案。</li></ol><ul><li><strong>开发：</strong> Vue CLI的 devServer.proxy。</li><li><strong>生产：</strong> 后端配置CORS 或 Nginx反向代理。</li></ul><ol start="3"><li><strong>强调代理原理：</strong> 能说出“代理利用服务器间通信无跨域限制”这个原理，会很加分。</li><li><strong>关键配置项：</strong> 提到changeOrigin: true的作用。</li><li><strong>自信表达：</strong> 这是一个非常常见的问题，回答时保持流畅和自信。</li></ol><h2 id="最终话术模板" tabindex="-1">最终话术模板 <a class="header-anchor" href="#最终话术模板" aria-label="Permalink to &quot;最终话术模板&quot;">​</a></h2><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span>“Vue中的跨域问题，其实是所有前端框架在开发时都会遇到的经典问题。它的根源是浏览器的同源策略。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>在开发阶段，我们通过在vue.config.js里配置devServer.proxy，利用Webpack-dev-server做一个代理服务器。这样，前端请求同源的代理，代理再去请求不同源的后端，就绕开了浏览器的限制。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>等项目上线后，这个代理配置就不管用了。生产环境主要有两种主流方案：一是最推荐的后端配置CORS，在响应头里设置Access-Control-Allow-Origin；二是在Nginx这类Web服务器上配置反向代理，原理和开发时的代理类似。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>所以，我们通常是在开发环境用Vue CLI的代理解决，上线时让后端开CORS或者运维配Nginx代理。”</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div>`,34)]))}const g=i(l,[["render",p]]);export{k as __pageData,g as default};
