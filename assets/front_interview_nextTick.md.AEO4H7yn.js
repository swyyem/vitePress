import{_ as i,c as a,o as n,aT as l}from"./chunks/framework.KoO-uqrk.js";const g=JSON.parse('{"title":"$nextTick的使用","description":"","frontmatter":{},"headers":[],"relativePath":"front/interview/nextTick.md","filePath":"front/interview/nextTick.md"}'),e={name:"front/interview/nextTick.md"};function p(t,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="nexttick的使用" tabindex="-1">$nextTick的使用 <a class="header-anchor" href="#nexttick的使用" aria-label="Permalink to &quot;$nextTick的使用&quot;">​</a></h1><p>“$nextTick 是 Vue 提供的一个异步方法，它的作用是将回调函数延迟到下一次DOM更新周期之后执行。通俗讲，就是等Vue帮你把数据变化“画”到页面上之后，再去执行你的代码。”</p><h2 id="_1-为什么需要-nexttick-问题的根源" tabindex="-1">1. 为什么需要 <code>$nextTick</code>？（问题的根源） <a class="header-anchor" href="#_1-为什么需要-nexttick-问题的根源" aria-label="Permalink to &quot;1. 为什么需要 \`$nextTick\`？（问题的根源）&quot;">​</a></h2><ul><li><strong>通俗解释：</strong> Vue的DOM更新是<strong>异步的</strong> 。</li></ul><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span>想象一个场景：你是一个老板（你写的JS代码），你有一群员工（Vue的渲染机制）。你下达了一连串指令（修改数据）：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1.“把A改成10！”</span></span>
<span class="line"><span>2.“把B改成20！”</span></span>
<span class="line"><span>3.“去看看A现在显示的是多少？”</span></span>
<span class="line"><span></span></span>
<span class="line"><span>如果你的员工是同步执行的（干完一件事再干下一件），那第3步你肯定能看到10。但Vue为了性能，是个“聪明”的员工，它会把你的指令先记下来（放入一个队列），然后一次性去完成所有修改。所以，在你下达第3条指令时，员工可能还没来得及去实际修改页面上的A，你看到的就是旧的值。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>代码示例：</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">message</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">新消息</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 修改数据</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">$el</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">textContent</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 这里打印出来的很可能还是『旧消息』</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 因为Vue的DOM更新是异步的，上面这行代码执行时，页面还没来得及重新渲染。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_2-nexttick-的作用是什么-解决方案" tabindex="-1">2. <code>$nextTick</code> 的作用是什么？（解决方案） <a class="header-anchor" href="#_2-nexttick-的作用是什么-解决方案" aria-label="Permalink to &quot;2. \`$nextTick\` 的作用是什么？（解决方案）&quot;">​</a></h2><ul><li><code>$nextTick</code> <strong>就相当于你对员工说：“等你把手头所有这些数据改动都更新到页面上之后，再叫我一声。”</strong> 它给你一个“保证”，保证你传入的回调函数会在<strong>下一次DOM更新循环结束之后</strong> 被调用。这时，你再去操作DOM或获取DOM属性，得到的就是更新后的最新状态。</li></ul><p><strong>修正上面的代码：</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">message</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">新消息</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 修改数据</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$nextTick</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">$el</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">textContent</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 这里打印出来的就是『新消息』了</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_3-nexttick-的使用场景" tabindex="-1">3. <code>$nextTick</code> 的使用场景 <a class="header-anchor" href="#_3-nexttick-的使用场景" aria-label="Permalink to &quot;3. \`$nextTick\` 的使用场景&quot;">​</a></h2><ol><li>操作依赖于更新后的DOM：</li></ol><ul><li>你想在数据改变后，立即获取一个更新后的DOM元素的尺寸、位置或内容。</li><li><strong>示例：</strong> 一个列表新增了一项后，滚动到最底部</li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">items</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">push</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">newItem</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$nextTick</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lastItem</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">$el</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">querySelector</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">.list-item:last-child</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  lastItem</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">scrollIntoView</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 此时才能正确滚动到新增的元素</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li>在组件更新后执行操作</li></ol><ul><li>当你修改了子组件的数据，想等子组件更新完毕后，再调用子组件的方法。</li><li><strong>示例：</strong> 一个可折叠的组件展开后，需要重新计算内部元素的布局。</li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">isExpanded</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 控制子组件展开</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$nextTick</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">$refs</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">childComponent</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">calculateLayout</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 确保子组件已渲染完成</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="3"><li>与第三方DOM库集成：</li></ol><ul><li>在使用jQuery插件等库时，需要确保Vue已经将数据渲染到DOM中，第三方库才能正确初始化。</li><li><strong>示例：</strong> 初始化一个图表库。</li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">chartData</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> newData</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$nextTick</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  $</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">#myChart</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">initChartPlugin</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 确保DOM元素已用新数据更新</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="面试回答技巧与要点总结" tabindex="-1">面试回答技巧与要点总结 <a class="header-anchor" href="#面试回答技巧与要点总结" aria-label="Permalink to &quot;面试回答技巧与要点总结&quot;">​</a></h2><ol><li><strong>先讲核心机制：</strong> 一定要先点明“Vue的DOM更新是<code>异步的</code>”，这是理解 <code>$nextTick</code> 的前提。</li><li><strong>用好比喻：</strong> 用“老板和员工”或“等Vue画完”的比喻，能让抽象的概念立刻变得具体。</li><li><strong>明确回答“等的是什么”：</strong> 强调是等待“下一次DOM更新周期”，而不仅仅是一个普通的 <code>setTimeout</code>。</li><li><strong>结合具体场景：</strong> 至少能说出1-2个典型的使用场景（如获取更新后DOM、与第三方库集成），证明你不仅懂概念，更有实践经验。</li><li><strong>提及返回值：</strong> 可以补充说明 <code>$nextTick</code> 返回一个Promise，因此可以用 <code>async/await</code> 语法，这显得你对现代用法很熟悉。</li></ol><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">async</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> myMethod</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">message</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">新消息</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  await</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$nextTick</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">DOM已更新！</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="最终话术模板" tabindex="-1">最终话术模板 <a class="header-anchor" href="#最终话术模板" aria-label="Permalink to &quot;最终话术模板&quot;">​</a></h2><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span>“$nextTick 是Vue中一个非常重要的API，它的核心作用是解决Vue异步更新DOM所带来的问题。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>由于Vue出于性能考虑，数据变化后并不会立即更新DOM，而是会将更新操作推入一个队列，在同一事件循环中批量执行。这就导致如果我们紧接着修改数据后就去操作DOM，拿到的还是旧的状态。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$nextTick 接收一个回调函数，并将这个回调延迟到下一次DOM更新循环结束之后执行。这确保了我们在回调函数内部操作DOM时，DOM已经完成了更新。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>它的典型使用场景包括：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>在数据变化后，需要获取更新后的DOM结构或属性时。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>在组件更新后，需要调用子组件方法时。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>在与依赖DOM的第三方库进行集成时。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>它既可以传入回调函数，也返回一个Promise，因此我们也可以使用更现代的 async/await 语法来使用它。”</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h1 id="nexttick能获取到最新dom是什么原理" tabindex="-1">$nextTick能获取到最新dom是什么原理 <a class="header-anchor" href="#nexttick能获取到最新dom是什么原理" aria-label="Permalink to &quot;$nextTick能获取到最新dom是什么原理&quot;">​</a></h1><p>“$nextTick 能获取到的是由你当前同步代码中所有数据变更所引发的那一次DOM更新后的结果。它保证你看到的是Vue响应式系统将数据‘同步’到视图后的最新状态，但不等同于浏览器已经将这些变化绘制到了屏幕上。”</p><h2 id="_1-nexttick-能获取到的-最新dom-是什么" tabindex="-1">1. $nextTick 能获取到的“最新DOM”是什么？ <a class="header-anchor" href="#_1-nexttick-能获取到的-最新dom-是什么" aria-label="Permalink to &quot;1. $nextTick 能获取到的“最新DOM”是什么？&quot;">​</a></h2><ul><li><p><strong>通俗解释：</strong> 想象Vue有一个“待办事项清单”（异步更新队列）。当你修改数据时，你只是在清单上添加了一项“更新DOM”。$nextTick 就像是说：“等你们处理完这个清单上所有当前积压的DOM更新任务后，再叫我。”</p></li><li><p>这个“最新DOM”具体指的是：</p></li></ul><h3 id="_1-由当前数据变化触发的dom更新" tabindex="-1">1.由当前数据变化触发的DOM更新： <a class="header-anchor" href="#_1-由当前数据变化触发的dom更新" aria-label="Permalink to &quot;1.由当前数据变化触发的DOM更新：&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">message</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Hello</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 数据变化1</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">isShow</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 数据变化2</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 数据变化3</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$nextTick</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 这里能获取到包含了以上所有3个数据变化所对应的DOM更新</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 比如：文本内容变为&#39;Hello&#39;，某个元素显示出来，计数器数字增加</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_2-组件渲染完成后的dom结构" tabindex="-1">2.组件渲染完成后的DOM结构： <a class="header-anchor" href="#_2-组件渲染完成后的dom结构" aria-label="Permalink to &quot;2.组件渲染完成后的DOM结构：&quot;">​</a></h3><ul><li>当子组件依赖父组件传递的props时，在 $nextTick 中能确保子组件已经用新的props重新渲染。</li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 父组件</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">userData</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> newData</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 更新传递给子组件的props</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$nextTick</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 此时子组件已经用newData重新渲染完成</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">$refs</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">child</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">doSomething</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 可以安全调用子组件方法</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_3-更新后的dom属性和布局信息" tabindex="-1">3.更新后的DOM属性和布局信息： <a class="header-anchor" href="#_3-更新后的dom属性和布局信息" aria-label="Permalink to &quot;3.更新后的DOM属性和布局信息：&quot;">​</a></h3><ul><li>能获取到元素更新后的宽高、位置等几何属性。</li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">isExpanded</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 这会改变元素的高度</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$nextTick</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> height</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">$refs</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">box</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">offsetHeight</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 获取的是展开后的真实高度</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_2-nexttick-不能保证什么-重要的界限" tabindex="-1">2.$nextTick 不能保证什么？（重要的界限） <a class="header-anchor" href="#_2-nexttick-不能保证什么-重要的界限" aria-label="Permalink to &quot;2.$nextTick 不能保证什么？（重要的界限）&quot;">​</a></h2><p>关键点：$nextTick 保证的是 Vue的虚拟DOM已经patch到真实DOM，但不保证浏览器已经完成了渲染流水线的所有步骤。</p><ul><li>Vue的更新周期：数据变化 → 虚拟DOM重新渲染 → 对比差异 → 更新真实DOM → $nextTick回调执行</li><li>浏览器的渲染周期：样式计算 → 布局 → 绘制 → 合成</li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">message</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">很长很长的新文本</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$nextTick</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> width</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">$el</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">offsetWidth</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // ✅ 能正确获取到包含新文本的宽度</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 因为此时新文本已经插入到DOM中了</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 但是，如果此时立即执行一个依赖最新布局的复杂动画</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 可能会因为浏览器尚未完成重绘而出现卡顿</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_3-与相关概念的对比" tabindex="-1">3. 与相关概念的对比 <a class="header-anchor" href="#_3-与相关概念的对比" aria-label="Permalink to &quot;3. 与相关概念的对比&quot;">​</a></h2><table tabindex="0"><thead><tr><th>时机</th><th>能获取到什么</th><th>不能保证什么</th></tr></thead><tbody><tr><td>同步代码中</td><td>数据变更前的DOM状态</td><td>数据变更后的DOM状态</td></tr><tr><td>$nextTick 中</td><td>✅ 当前数据变更引起的DOM更新</td><td>❌ 浏览器已完成绘制和渲染</td></tr><tr><td>setTimeout(fn, 0) 中</td><td>✅ 通常也能拿到更新后的DOM（因为更晚执行）</td><td>❌ 时机不可控，可能晚于需要的</td></tr></tbody></table><h2 id="面试回答技巧与要点总结-1" tabindex="-1">面试回答技巧与要点总结 <a class="header-anchor" href="#面试回答技巧与要点总结-1" aria-label="Permalink to &quot;面试回答技巧与要点总结&quot;">​</a></h2><ol><li>精确描述：不要说“等页面渲染完成”，而要说“等Vue完成DOM更新”。</li><li>强调“当前轮次”：重点说明它等待的是当前这轮事件循环中的所有Vue DOM更新。</li><li>划清界限：主动说明 $nextTick 与浏览器渲染的区别，这能体现你的深度理解。</li><li>用对比加强理解：通过对比同步代码、$nextTick、setTimeout 的不同表现来强化认知。</li><li>结合具体API：提到能获取 offsetHeight、clientWidth 等布局信息，证明你有实践经验。</li></ol><h2 id="最终话术模板-1" tabindex="-1">最终话术模板 <a class="header-anchor" href="#最终话术模板-1" aria-label="Permalink to &quot;最终话术模板&quot;">​</a></h2><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span>“$nextTick 能获取到的‘最新DOM’，特指的是在当前这个事件循环中，由所有响应式数据变化所触发的那一次Vue DOM更新之后的结果。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>具体来说，当我修改了多个数据后，在 $nextTick 的回调里，我能获取到这些数据变化已经全部应用到真实DOM上之后的状态。比如元素的文本内容、显示隐藏状态、以及基于新内容计算出的尺寸和位置信息等。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>但是需要明确一个重要的界限：$nextTick 只保证Vue的虚拟DOM已经patch到了真实DOM，并不保证浏览器已经完成了后续的布局、绘制等渲染流水线。不过在实际开发中，对于绝大多数操作（比如获取元素尺寸、操作DOM结构），在 $nextTick 中已经完全足够了。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>与之相对的是，如果在同步代码中立即获取DOM，拿到的一定是更新前的旧状态，因为Vue的DOM更新是异步批处理的。而如果用 setTimeout(fn, 0)，虽然通常也能 work，但它的时机不如 $nextTick 精确和可靠。”</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div>`,48)]))}const o=i(e,[["render",p]]);export{g as __pageData,o as default};
