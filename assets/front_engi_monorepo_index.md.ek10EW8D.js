import{_ as o,c as a,o as s,aT as n}from"./chunks/framework.KoO-uqrk.js";const r="/vitePress/assets/fileStruc.LsLUPeNw.png",t="/vitePress/assets/utils-pkj.3uAFcTDE.png",l="/vitePress/assets/demo1Pkj.Cn_iIAQa.png",i="/vitePress/assets/demo1Sub.FkCkd6M0.png",p="/vitePress/assets/useSub.BRLb122v.png",c="/vitePress/assets/completeStruc.GRNjY6OO.png",v=JSON.parse('{"title":"Monorepo 理论与实践","description":"","frontmatter":{},"headers":[],"relativePath":"front/engi/monorepo/index.md","filePath":"front/engi/monorepo/index.md"}'),d={name:"front/engi/monorepo/index.md"};function m(g,e,h,u,b,_){return s(),a("div",null,e[0]||(e[0]=[n(`<h1 id="monorepo-理论与实践" tabindex="-1">Monorepo 理论与实践 <a class="header-anchor" href="#monorepo-理论与实践" aria-label="Permalink to &quot;Monorepo 理论与实践&quot;">​</a></h1><h2 id="什么是-monorepo" tabindex="-1">什么是 Monorepo <a class="header-anchor" href="#什么是-monorepo" aria-label="Permalink to &quot;什么是 Monorepo&quot;">​</a></h2><p>Monorepo（单仓多包）是一种仓库管理模式，指的是将多个项目的代码存储在同一个版本控制仓库中，而不是将每个项目分成单独的仓库。它是一种代码管理策略，特别适用于大型项目或有多个子项目需要共享代码的情况</p><h2 id="monorepo-的优劣势" tabindex="-1">Monorepo 的优劣势 <a class="header-anchor" href="#monorepo-的优劣势" aria-label="Permalink to &quot;Monorepo 的优劣势&quot;">​</a></h2><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li><strong>可复用性</strong>：仓库内各子项目间代码共享和复用，如公共函数、公共组件、三方依赖包等等，同时各个子项目又能作为单独的发包和部署单位</li><li><strong>一致性</strong>：开发工具、配置和依赖版本在所有项目中保持一致，降低管理复杂性。简化依赖管理：通过工具（如 Yarn Workspaces 或 PNPM Workspaces）统一管理依赖，减少版本冲突。</li><li><strong>原子性</strong>：可以同时更新多个项目中的相关代码，确保功能改动的同步性。</li><li><strong>可管理性</strong>：公共包和对应业务域下的子项目在一个仓库中，组内授权，代码 MR、CR 等更为方便，查看代码历史提交记录也更为直观</li></ul><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li><strong>仓库大</strong>：随着项目迭代，仓库内容会越来越多，体积会越来越大，后续代码克隆耗时增加</li><li><strong>权限颗粒度</strong>：因为是单一仓库，所以权限为单一权限，当多团队协作时，较难根据团队来分配仓库权限</li><li><strong>组件跨仓库</strong>：如果后续涉及到跨代码仓库的项目间的公共组件、函数复用，迁移成本相对较高</li></ul><h2 id="monorepo-适用于哪些场景" tabindex="-1">Monorepo 适用于哪些场景 <a class="header-anchor" href="#monorepo-适用于哪些场景" aria-label="Permalink to &quot;Monorepo 适用于哪些场景&quot;">​</a></h2><p>根据上述优劣势的分析来看，不是所有时候 Monorepo 都是最好的选择，我们应该根据项目的实际情况来选择对应的方案，那么 Monorepo 适用于哪些场景呢？</p><h3 id="适用" tabindex="-1">适用 <a class="header-anchor" href="#适用" aria-label="Permalink to &quot;适用&quot;">​</a></h3><ul><li>前端组件库项目，公共组件包、业务组件包、测试项目包等均可一起管理，项目复用</li><li>同业务域下多个相似业务项目，当某个业务域下有多个相似（UI 界面、交互）的项目时，可以通过 Monorepo 的管理方式以 workspace 协议相互引用实现公共组件和页面间的复用</li><li>小规模团队同时维护多个相同技术栈的业务项目，可以以 Monorepo 的管理方式进行代码复用，避免了通过 npm 包管理的发包，版本管理等繁琐流程</li></ul><h3 id="不适用" tabindex="-1">不适用 <a class="header-anchor" href="#不适用" aria-label="Permalink to &quot;不适用&quot;">​</a></h3><ul><li>项目体积庞大，且各个子项目之间技术栈各不相同，如微前端架构下的各个技术栈不同的子项目</li><li>项目涉及到多团队甚至跨部门的人员，需要区分不同仓库权限</li></ul><h2 id="从-0-到-1-去构建一个-monorepo-项目" tabindex="-1">从 0 到 1 去构建一个 monorepo 项目 <a class="header-anchor" href="#从-0-到-1-去构建一个-monorepo-项目" aria-label="Permalink to &quot;从 0 到 1 去构建一个 monorepo 项目&quot;">​</a></h2><ol><li><strong>确定包管理工具</strong>：如 Pnpm 或 Yarn+Lerna,由于 Pnpm 天然支持 workspace 协议，本 demo 以 pnpm 作为包管理工具</li><li><strong>初始化根项目</strong>：</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span>mkdir monorepo-demo</span></span>
<span class="line"><span>cd monorepo-demo</span></span>
<span class="line"><span></span></span>
<span class="line"><span>pnpm init</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="3"><li><strong>声明 workspace 协议作用范围</strong>：在根目录创建 pnpm-workspace.yaml,并在其中声明子项目包的位置</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" tabindex="0"><code><span class="line"><span>packages:</span></span>
<span class="line"><span>  - &quot;packages/*&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="4"><li><strong>创建 packages 文件夹用于存放各个子项目</strong></li></ol><p><img src="`+r+'" alt="alt text"></p><ol start="5"><li><strong>初始化各个子项目</strong></li></ol><p>各个子项目执行 pnpm init,并且修改对应 name 名 <img src="'+t+'" alt="alt text"></p><ol start="6"><li><p><strong>根据引用关系添加 dependence</strong></p><ol><li><img src="'+l+'" alt="alt text"></li><li>pnpm i 安装依赖</li><li>在 demo1 子项目的 node-modules 中生成了对应子包即为成功 <img src="'+i+'" alt="alt text"></li></ol></li><li><p>在 demo1 中使用 utils 子包的资源 <img src="'+p+'" alt="alt text"></p></li><li><p>目前一个 monorepo 架构的仓库已经搭建完成，子项目间可通过 workspace 协议进行资源互相引用，另外，可以在根项目中做好 eslint,cz,prettier 等公共配置，可统一作用于各个子项目，让项目更加规范，具体配置可以参考博客中<a href="https://doggyegg.github.io/charlie-blog/front/engi/rule/" target="_blank" rel="noreferrer">前端规范化</a>，最终一个完整的项目结构如下：</p></li></ol><p><img src="'+c+'" alt="alt text"></p><ol><li>示例项目链接：<a href="https://github.com/doggyegg/charlie-ec" target="_blank" rel="noreferrer">https://github.com/doggyegg/charlie-ec</a></li></ol>',26)]))}const f=o(d,[["render",m]]);export{v as __pageData,f as default};
