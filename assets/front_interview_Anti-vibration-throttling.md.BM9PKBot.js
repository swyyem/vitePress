import{_ as e,c as r,o as n,aQ as l}from"./chunks/framework.CtsLwA2Q.js";const c=JSON.parse('{"title":"防抖和节流详解：性能优化的\\"刹车系统\\"","description":"","frontmatter":{},"headers":[],"relativePath":"front/interview/Anti-vibration-throttling.md","filePath":"front/interview/Anti-vibration-throttling.md"}'),o={name:"front/interview/Anti-vibration-throttling.md"};function i(s,t,a,g,m,d){return n(),r("div",null,t[0]||(t[0]=[l('<h1 id="防抖和节流详解-性能优化的-刹车系统" tabindex="-1">防抖和节流详解：性能优化的&quot;刹车系统&quot; <a class="header-anchor" href="#防抖和节流详解-性能优化的-刹车系统" aria-label="Permalink to &quot;防抖和节流详解：性能优化的&quot;刹车系统&quot;&quot;">​</a></h1><h2 id="核心思想-性能优化" tabindex="-1">核心思想：性能优化 <a class="header-anchor" href="#核心思想-性能优化" aria-label="Permalink to &quot;核心思想：性能优化&quot;">​</a></h2><p><em><strong>防抖和节流的核心目的都是为了限制函数的执行频率，避免在短时间内触发大量不必要的计算或请求，从而提升性能和使用体验。它们解决的都是“高频事件”带来的问题。</strong></em></p><h2 id="_1-防抖" tabindex="-1">1. 防抖 <a class="header-anchor" href="#_1-防抖" aria-label="Permalink to &quot;1. 防抖&quot;">​</a></h2><h3 id="通俗理解-等你说完我再动" tabindex="-1">通俗理解：“等你说完我再动” <a class="header-anchor" href="#通俗理解-等你说完我再动" aria-label="Permalink to &quot;通俗理解：“等你说完我再动”&quot;">​</a></h3><ul><li><p>想象一个场景：你在电梯门口，电梯门开始关闭。这时有人跑过来，电梯门检测到有人，就会重新打开。如果不断有人跑过来，电梯门就会<em><strong>一直处于“重新开门”的状态，直到没有人再来，它才会等待一段时间后真正关闭</strong></em></p></li><li><p><em><strong>防抖的精髓就是</strong></em>： 在事件被触发后，等待一个设定的时间。如果在这个等待期内，事件又被触发，则重新开始计时。只有当等待期内事件不再被触发，函数才会执行。</p></li><li><p><em><strong>应用场景</strong></em>：</p><ul><li><p>搜索框输入联想（最经典的例子）</p><ul><li><em><strong>问题</strong></em>： 用户每输入一个字母就向服务器发送一次请求，会造成巨大的服务器压力，且可能返回顺序错乱的结果。</li><li><em><strong>解决</strong></em>： 使用防抖，只有当用户停止输入（比如500毫秒内没再打字）后，才去发送请求。</li></ul></li><li><p>窗口大小调整</p><ul><li><em><strong>问题</strong></em>： 用户拖拽浏览器窗口时，会连续触发 <code>resize</code> 事件，如果这里面的计算逻辑很复杂，会导致页面卡顿。</li><li><em><strong>解决</strong></em>： 使用防抖，直到用户<em><strong>调整完窗口大小</strong></em>后，再执行计算布局的函数。</li></ul></li><li><p><em><strong>表单验证</strong></em>：</p><ul><li><em><strong>问题</strong></em>： 用户输入过程中就实时验证格式（比如密码强度），可能会干扰用户。</li><li><em><strong>解决</strong></em>： 使用防抖，在用户<em><strong>输入完毕</strong></em>后（比如停止输入1秒后）再进行验证</li></ul></li><li><p><em><strong>按钮提交（防止重复提交）</strong></em>：</p><ul><li><em><strong>问题</strong></em>： 用户疯狂点击提交按钮，可能会导致表单被重复提交多次。</li><li><em><strong>解决</strong></em>： 使用防抖，在用户第一次点击后，在设定的时间内，后续的点击无效。</li></ul></li></ul></li></ul><h3 id="面试回答示例" tabindex="-1">面试回答示例： <a class="header-anchor" href="#面试回答示例" aria-label="Permalink to &quot;面试回答示例：&quot;">​</a></h3><p>“防抖的核心是，在事件被频繁触发时，我只执行最后一次。比如搜索框的联想功能，我不会在用户每输入一个字符时就请求，而是会设置一个计时器，等他停止输入一段时间（比如300毫秒）后，才去发起请求，这样可以有效减少服务器压力。”</p><h2 id="_2-节流" tabindex="-1">2. 节流 <a class="header-anchor" href="#_2-节流" aria-label="Permalink to &quot;2. 节流&quot;">​</a></h2><h3 id="通俗理解-按规定节奏来" tabindex="-1">通俗理解：“按规定节奏来” <a class="header-anchor" href="#通俗理解-按规定节奏来" aria-label="Permalink to &quot;通俗理解：“按规定节奏来”&quot;">​</a></h3><ul><li>想象一个场景：地铁站的闸机，人流再大，也<em><strong>只能一个一个通过，并且通过的速度是固定的</strong></em>。你不可能因为10个人同时挤在闸机口，就让10个人瞬间通过。</li><li><em><strong>节流的精髓就是</strong></em>： 在一个单位时间内，无论事件被触发了多少次，函数都只会执行一次。</li><li><em><strong>技术上的应用场景</strong></em>： <ul><li><em><strong>滚动加载更多 / 无限滚动</strong></em><ul><li><em><strong>问题</strong></em>： 监听页面滚动事件 <code>scroll</code>，用户一滚动就会触发非常多次。如果每次触发都去计算位置并判断是否要加载，性能会很差。</li><li><em><strong>解决</strong></em>： 使用节流，比如每<code>500毫秒</code>才检查一次滚动位置，判断是否需要加载新内容。</li></ul></li><li><em><strong>鼠标移动 / 元素拖拽</strong></em><ul><li><em><strong>问题</strong></em>： 监听 <code>mousemove</code> 事件，鼠标稍微移动一下就会触发几十次。</li><li><em><strong>解决</strong></em>： 使用节流，保证跟随鼠标移动的元素（比如一个高亮框）的更新频率是固定的，比如每100毫秒更新一次位置，避免卡顿。</li></ul></li><li><em><strong>抢购按钮的点击</strong></em><ul><li><em><strong>问题</strong></em>： 用户疯狂点击“立即抢购”按钮。</li><li><em><strong>解决</strong></em>： 使用节流，比如设置每1秒内只能提交一次请求，即使用户点了10下，也只有第一下和1秒后的第一下是有效的。</li></ul></li><li><em><strong>播放器记录播放时间</strong></em><ul><li><em><strong>问题</strong></em>： 视频 <code>timeupdate</code> 事件触发频率很高，如果每次都向服务器记录播放进度，请求会太多。</li><li><em><strong>解决</strong></em>： 使用节流，每5秒才记录一次播放进度。</li></ul></li></ul></li></ul><h3 id="面试回答示例-1" tabindex="-1">面试回答示例： <a class="header-anchor" href="#面试回答示例-1" aria-label="Permalink to &quot;面试回答示例：&quot;">​</a></h3><p>“节流的核心是，保证一个函数在固定的时间间隔内只执行一次。比如在实现滚动加载更多时，滚动事件会高频触发，但我可以用节流让它每300毫秒才去判断一次是否滚到了底部，而不是每次都去判断，这样就大大优化了性能。”</p><h2 id="总结与对比-面试黄金法则" tabindex="-1">总结与对比（面试黄金法则） <a class="header-anchor" href="#总结与对比-面试黄金法则" aria-label="Permalink to &quot;总结与对比（面试黄金法则）&quot;">​</a></h2><div class="markdown-table-wrapper"><table><thead><tr><th style="text-align:center;">特性</th><th style="text-align:center;"><strong>_防抖 _</strong></th><th style="text-align:center;"><strong>_节流 _</strong></th></tr></thead><tbody><tr><td style="text-align:center;"><strong>_核心思想 _</strong></td><td style="text-align:center;">延迟执行，<strong>_只执行最后一次 _</strong></td><td style="text-align:center;">间隔执行，<strong>_按固定频率执行 _</strong></td></tr><tr><td style="text-align:center;"><strong>_生活比喻 _</strong></td><td style="text-align:center;"><em><strong>电梯门</strong></em>：等人走光了再关门</td><td style="text-align:center;"><em><strong>地铁闸机</strong></em>：每分钟只过10个人</td></tr><tr><td style="text-align:center;"><em><strong>关系图</strong></em></td><td style="text-align:center;">事件触发 ...(等待)...&gt; 执行函数</td><td style="text-align:center;">事件触发 -&gt; 执行函数 ...(冷却)...&gt; 执行函数</td></tr><tr><td style="text-align:center;"><em><strong>应用关键词</strong></em></td><td style="text-align:center;"><em><strong>等一等，直到停下</strong></em></td><td style="text-align:center;"><strong>_有节奏，控制频率 _</strong></td></tr><tr><td style="text-align:center;"><em><strong>经典场景</strong></em></td><td style="text-align:center;">搜索联想、窗口调整</td><td style="text-align:center;">滚动加载、鼠标移动</td></tr></tbody></table></div><h2 id="如何记忆" tabindex="-1">如何记忆？ <a class="header-anchor" href="#如何记忆" aria-label="Permalink to &quot;如何记忆？&quot;">​</a></h2><ul><li>手抖了，抖一抖就只认最后一次 -&gt; <em><strong>防抖</strong></em></li><li>节约流量，细水长流 -&gt; <em><strong>节流</strong></em></li><li>在面试中，清晰地表达出 <em><strong>“为什么用”</strong></em> 和 <em><strong>“它们之间的区别”</strong></em> ，并配上一两个生动的例子，就足以让面试官对你留下深刻印象了。</li></ul>',17)]))}const u=e(o,[["render",i]]);export{c as __pageData,u as default};
